
module Lecture6

where 

import Test.QuickCheck 
import Data.List
import System.Random
import System.IO.Unsafe

-- Source: https://stackoverflow.com/a/4695002
isPrime k = null [ x | x <- [2..k - 1], k `mod`x  == 0]

-------------------------------------------------------------------------------
-- == Exercise 1 == --
exM :: Integer -> Integer -> Integer -> Integer
exM x 0 divisor = 1 `rem` divisor
exM x power divisor | even power = (exM x (power `div` 2) divisor)^2 `rem` divisor
                    | otherwise = (exM x (power-1) divisor * x) `rem` divisor

-------------------------------------------------------------------------------
-- == Exercise 2 == --

{-
I like it well enough now:
*Sjoerd_Lab6> :set +s
*Sjoerd_Lab6> expM 9999999 999999 53425021
7655597
(0.41 secs, 8,308,576 bytes)
*Sjoerd_Lab6> exM 9999999 999999 53425021
7655597
(0.02 secs, 76,352 bytes)

This shows that my exM function is a lot more efficient than the old exM function.
-}

-------------------------------------------------------------------------------
-- == Exercise 3 == --
composites :: [Integer]
composites = [n | n <- [1..], not (isPrime n) ]

doExec3 = do
    putStrLn "-- == Exercise 3 == --" 
    putStrLn "Showing 10 composites" 
    putStrLn (show (take 10 (composites)) )

-------------------------------------------------------------------------------
-- == Exercise 4 == --
fBreaker :: Int -> [Integer]
fBreaker k = [composite | composite <- composites, unsafePerformIO (primeTestsF k composite)]

doExec4 = do
    putStrLn "-- == Exercise 4 == --" 
    putStrLn "Showing 10 composite numbers that pass primeTestsF for k = 2" 
    putStrLn (show (take 10 (fBreaker 2)) )

{-
 I should've used unsafePerformIO so much sooner, it is beautiful and makes
 everything so much easier.
 The least composite number wrongly labeled as prime I have found is 9.
 If you increase k, primeTestsF performs more tests to see whether the other
 input number is prime, thus reducing the chance that a composite is wrongly
 labeled as a prime.
-}

-------------------------------------------------------------------------------
-- == Exercise 5 == --

carmichael :: [Integer]
carmichael = [ (6*k+1)*(12*k+1)*(18*k+1) | 
        k <- [2..], 
        prime (6*k+1), 
        prime (12*k+1), 
        prime (18*k+1) ]

fBreakerCarmichael :: Int -> [Integer]
fBreakerCarmichael k = [nCarmichael | nCarmichael <- carmichael, unsafePerformIO (primeTestsF k nCarmichael)]

doExec5 = do 
    putStrLn "-- == Exercise 5 == --" 
    putStrLn "Showing carmichael numbers that pass primeTestsF for k = 1"
    putStrLn (show (take 5 (fBreakerCarmichael 1)))
    putStrLn "Showing carmichael numbers that pass primeTestsF for k = 1000"
    putStrLn (show (take 5 (fBreakerCarmichael 1000)))

{-
 Each carmichael number very often gives a false positive in primeTestsF.
 All carmichael numbers Carmichael numbers should always give false positives
 in primeTestsF, as these numbers are required to satisfy the same condition
 that primeTestsF uses to check whether a number is prime.
 Unless! if the random number a generated by primeTestsF and the carmichael number 
 that is being tested have a gcd > 1, the property for the carmichael number no 
 longer holds, and primeTestsF will find that the carmichael number is not prime.
 In other words, if the random number generated by primeTestsF is either prime (6*k+1), 
 prime (12*k+1), or prime (18*k+1), primeTestsF will not give a false positive. This
 is a rather rare event, however.
-}

-------------------------------------------------------------------------------
-- == Exercise 6 == --
mrBreakerCarmichael :: Int -> [Integer]
mrBreakerCarmichael k = [nCarmichael | nCarmichael <- carmichael, unsafePerformIO (primeMR k nCarmichael)]

doExec6_1 = do
    putStrLn "-- == Exercise 6.1 == --" 
    putStrLn "Showing 5 carmichael numbers that pass primeMR"
    putStrLn (show (take 5 (mrBreakerCarmichael 2)) )
{-
 primeMR returns fewer false positives for carmichael numbers.
 This is as expected, as the property that is tested for in primeMR is different
 than the property of Carmichael numbers, contrary to primeTestsF.
-}

-------------------------------------------------------------------------------
-- == Exercise 6: round 2 == --
-- Source: Turner's sieve, https://wiki.haskell.org/Prime_numbers
primesT :: [Int]
primesT = sieve [2..]
          where
          sieve (p:xs) = p : sieve [x | x <- xs, rem x p > 0]

-- mersennePrimes = [(2^p)-1 | p <- primesT, isPrime ((2^p)-1) ]
mersennePrimes = [(2^p)-1 | p <- primesT, unsafePerformIO (primeMR 3 ((2^p)-1)) ]

doExec6_2 = do
    putStrLn "-- == Exercise 6.2 == --" 
    putStrLn "Showing the 15 first Mersenne primes"
    putStrLn (show (take 15 mersennePrimes) )


-------------------------------------------------------------------------------
-- == Exercise 7 == --

-- Source: https://wiki.haskell.org/Prime_numbers#Calculating_Primes_in_a_Given_Range
-- primesFromToA a b = (if a<3 then [2] else []) 
--                       ++ [i | i <- [o,o+2..b], ar ! i]
--   where 
--     o  = max (if even a then a+1 else a) 3   -- first odd in the segment
--     r  = floor . sqrt $ fromIntegral b + 1
--     ar = accumArray (\_ _ -> False) True (o,b)  -- initially all True,
--           [(i,()) | p <- [3,5..r]
--                     , let q  = p*p      -- flip every multiple of an odd 
--                           s  = 2*p                         -- to False
--                           (n,x) = quotRem (o - q) s 
--                           q2 = if  o <= q  then q
--                                else  q + (n + signum x)*s
--                     , i <- [q2,q2+s..b] ]

 -- [ x <- [2^n..2^(n+1)-1], primeMR 5 x ]

randomPrimeGen :: Integer -> Integer -> IO Integer
randomPrimeGen n m = do
    x <- randomRIO (2^n,2^(n+1)-1)
    isprime <- primeMR 5 x
    if (isprime && x /= m) then return x else randomPrimeGen n m

ex7Demonstration :: Integer -> Integer -> IO (Integer, Integer)
ex7Demonstration x bitlength = do
    p <- randomPrimeGen bitlength 0
    q <- randomPrimeGen bitlength p
    let e = rsaPublic p q
    let d = rsaPrivate p q
    let encodedX = rsaEncode e (mod x (p*q))
    let decodedX = rsaDecode d encodedX
    -- return (mod x (p*q), decodedX, p , q)
    return (mod x (p*q), decodedX)

-- ex7quickCheck :: Integer -> IO Bool
-- ex7quickCheck x = do 
--     result <- ex7Demonstration x 10
--     return (fst result == snd result)
--     -- where result = ex7Demonstration x 10

ex7quickCheck :: Integer -> Bool
ex7quickCheck x = fst result == snd result
    where result = unsafePerformIO (ex7Demonstration x 10 )

doExec7 = do
    putStrLn "-- == Exercise 7.2 == --" 
    putStrLn "Checking whether x mod n == x^(ed) mod n for 100 x:"
    quickCheck ex7quickCheck

-------------------------------------------------------------------------------
-- == Main == --
main = do
    doExec3
    doExec4
    doExec5
    doExec6_1
    doExec6_2
    doExec7



-------------------------------------------------------------------------------
-- Lecture code
factorsNaive :: Integer -> [Integer]
factorsNaive n0 = factors' n0 2 where 
  factors' 1 _ = []
  factors' n m 
    | n `mod` m == 0 = m : factors' (n `div` m) m
    | otherwise      =     factors' n (m+1)

factors :: Integer -> [Integer]
factors n0 = let
   ps0 = takeWhile (\ m -> m^2 <= n0) primes
 in factors' n0 ps0 where 
   factors' 1 _  = []
   factors' n [] = [n]
   factors' n (p:ps) 
    | n `mod` p == 0 = p: factors' (n `div` p) (p:ps)
    | otherwise      =    factors' n ps

prime :: Integer -> Bool
prime n = factors n == [n]

primes :: [Integer]
primes = 2 : filter prime [3..]

mers :: Integer -> Integer
mers 1  = 2^2-1;    mers 2  = 2^3-1;     mers 3  = 2^5-1
mers 4  = 2^7-1;    mers 5  = 2^13-1;    mers 6  = 2^17-1
mers 7  = 2^19-1;   mers 8  = 2^31-1;    mers 9  = 2^61-1
mers 10 = 2^89-1;   mers 11 = 2^107-1;   mers 12 = 2^127-1
mers 13 = 2^521-1;  mers 14 = 2^607-1;   mers 15 = 2^1279-1
mers 16 = 2^2203-1; mers 17 = 2^2281-1;  mers 18 = 2^3217-1
mers 19 = 2^4253-1; mers 20 = 2^4423-1;  mers 21 = 2^9689-1
mers 22 = 2^9941-1; mers 23 = 2^11213-1; mers 24 = 2^19937-1
mers 25 = 2^21701-1;
mers _  = undefined

bin2int :: [Int] -> Int
bin2int = bin . reverse where
  bin []  = 0
  bin [0] = 0
  bin [1] = 1
  bin (0:bs) = 2 * bin bs
  bin (1:bs) = 2 * bin bs + 1
  bin _      = error "not a binary digit list"

addM :: Integer -> Integer -> Integer -> Integer
addM x y = rem (x+y)

multM :: Integer -> Integer -> Integer -> Integer
multM x y = rem (x*y) 

invM :: Integer -> Integer -> Integer
invM x n = let 
   (u,v) = fctGcd x n
   copr  = x*u + v*n == 1
   i     = if signum u == 1 then u else u + n  
 in 
   if copr then i else error "no inverse"

fGcd :: Integer -> Integer -> Integer
fGcd a b = if b == 0 then a
                     else fGcd b (rem a b)

fctGcd :: Integer -> Integer -> (Integer,Integer) 
fctGcd a b = 
  if b == 0 
  then (1,0) 
  else 
     let 
       (q,r) = quotRem a b
       (s,t) = fctGcd b r 
     in (t, s - q*t)

coprime :: Integer -> Integer -> Bool
coprime n m = fGcd n m == 1

coprime' :: Integer -> Integer -> Bool
coprime' n m = let (x,y) = fctGcd n m
               in x*n + y*m == 1

data Tree a = T a [Tree a] deriving (Eq,Ord,Show)

grow :: (node -> [node]) -> node -> Tree node

grow step seed = T seed (map (grow step) (step seed))

takeT :: Int -> Tree a -> Tree a

takeT 0 (T x _) = T x []
takeT n (T x ts) = T x (map (takeT (n-1)) ts)

coprimeT :: Tree (Integer,Integer)
coprimeT = grow f (1,1) 

f :: (Integer,Integer) -> [(Integer,Integer)]
f (n,m) = [(n+m,m),(n,n+m)]

pairs :: [(Integer,Integer)]
pairs = concatMap (\ n -> zip [1..n] (repeat n)) [1..]

coprimes :: [(Integer,Integer)]
coprimes = filter (uncurry coprime) pairs

expM ::  Integer -> Integer -> (Integer -> Integer)
expM x y = rem (x^y)

-- exM :: Integer -> Integer -> Integer -> Integer
-- exM = expM -- to be replaced by a fast version

primeTestF :: Integer -> IO Bool
primeTestF n = do 
   a <- randomRIO (2, n-1) :: IO Integer
   return (exM a (n-1) n == 1)

primeTestsF :: Int -> Integer -> IO Bool
primeTestsF k n = do
 as <- sequence $ fmap (\_-> randomRIO (2,n-1)) [1..k]
 return (all (\ a -> exM a (n-1) n == 1) as)

decomp :: Integer -> (Integer,Integer)
decomp n0 = decomp' (0,n0) where
  decomp' = until (odd.snd) (\ (m,n) -> (m+1,div n 2))

mrComposite :: Integer -> Integer -> Bool
mrComposite x n = let
    (r,s) = decomp (n-1)
    fs     = takeWhile (/= 1) 
       (map (\ j -> exM x (2^j*s) n)  [0..r])
  in 
    exM x s n /= 1 && last fs /= (n-1)

primeMR :: Int -> Integer -> IO Bool
primeMR _ 2 = return True
primeMR 0 _ = return True
primeMR k n = do 
    a <- randomRIO (2, n-1) :: IO Integer
    if exM a (n-1) n /= 1 || mrComposite a n
    then return False else primeMR (k-1) n

-- composites :: [Integer]
-- composites = error "not yet implemented"

encodeDH :: Integer -> Integer -> Integer -> Integer
encodeDH p k m = m*k `mod` p

decodeDH :: Integer -> Integer -> Integer -> Integer -> Integer
decodeDH p ga b c = let 
    gab' = exM ga ((p-1)-b) p 
  in 
    rem (c*gab') p

encode :: Integer -> Integer -> Integer -> Integer
encode p k m = let 
   p' = p-1
   e  = head [ x | x <- [k..], gcd x p' == 1 ]
 in 
   exM m e p

decode :: Integer -> Integer -> Integer -> Integer
decode p k m = let 
   p' = p-1
   e  = head [ x | x <- [k..], gcd x p' == 1 ]
   d  = invM e p' 
 in 
   exM m d p

cipher :: Integer -> Integer
cipher = encode secret bound

decipher :: Integer -> Integer
decipher = decode secret bound

totient :: Integer -> Integer
totient n = toInteger $ length [ k | k <- [1..n], gcd k n == 1 ]

phi :: Integer -> Integer -> Integer
phi p q = (p - 1) * (q - 1)

select :: Integer -> Integer -> Integer
select p q = let
   t = phi p q 
 in
   head [ x | x <- [3..], gcd x t == 1 ]

rsaPublic :: Integer -> Integer -> (Integer,Integer)
rsaPublic p q = let
    e = select p q
  in
    (e,p*q)

rsaPrivate ::  Integer -> Integer -> (Integer,Integer)
rsaPrivate p q = let 
   e = select p q
   t = phi p q 
   d = invM e t
  in 
   (d,p*q)

rsaEncode :: (Integer,Integer) -> Integer -> Integer 
rsaEncode (e,n) m =  exM m e n

rsaDecode :: (Integer,Integer) -> Integer -> Integer 
rsaDecode = rsaEncode                              

trapdoor :: (Integer,Integer) -> Integer -> Integer
trapdoor = rsaEncode 

secret, bound :: Integer                
secret = mers 18
bound  = 131

