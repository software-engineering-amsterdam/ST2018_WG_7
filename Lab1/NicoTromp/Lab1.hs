
module Lab1 where
import Data.List
import Test.QuickCheck    

prime :: Integer -> Bool
prime n = n > 1 && all (\x -> rem n x /= 0) xs
  where xs = takeWhile (\y -> y^2 <= n) primes

primes :: [Integer]
primes = 2 : filter prime [3..] 

infix 1 --> 

(-->) :: Bool -> Bool -> Bool
p --> q = (not p) || q

forall :: [a] -> (a -> Bool) -> Bool
forall = flip all

reversal :: Integer -> Integer
reversal = read . reverse . show

data Boy = Matthew | Peter | Jack | Arnold | Carl 
           deriving (Eq,Show)

boys = [Matthew, Peter, Jack, Arnold, Carl]


-- ASSIGNMENT 1.1 --

-- show that 1^2 + 2^2 + 3^2 + ... + n^2 == n(n+1)(2n+1)/6 holds

sumOfSquares :: Int -> Int
sumOfSquares n = sum [ x^2 | x <- [1..n]]

formalSumOfSquares :: Int -> Int
formalSumOfSquares n = n * (n + 1) * (2 * n + 1) `div` 6

sumOfSquaresTest :: (Positive Int) -> Bool
--sumOfSquaresTest n = sumOfSquares (abs n) == formalSumOfSquares (abs n)
--sumOfSquaresTest n = n > 0 --> sumOfSquares n == formalSumOfSquares n
sumOfSquaresTest (Positive n) = sumOfSquares n == formalSumOfSquares n
-- The downside of this approach is that you only use (roughly) half of the numbers generated by QuickCheck!

-- 2 hours, including catching up on Haskell (first version in 45 minutes)

-- Show that 1^3 + 2^3 + 3^3 + ... + n^3 == (n(n+1)/2)^2 holds

sumOfQubic :: Int -> Int
sumOfQubic n = sum [ x^3 | x <- [1..n]]

formalSumOfQubic :: Int -> Int
formalSumOfQubic n = (n * (n + 1) `div` 2) ^ 2

sumOfQubicTest :: (Positive Int) -> Bool
--sumOfQubicTest n = sumOfQubic (abs n) == formalSumOfQubic (abs n)
sumOfQubicTest (Positive n) = n > 0 --> sumOfQubic n == formalSumOfQubic n

-- 10 minutes, including changing after swithing to the infix --> operation


-- ASSIGNMENT 1.2 --
-- Power set

powerSetSizeTest :: (Positive Int) -> Bool
powerSetSizeTest (Positive n) = n <= 15 --> length (subsequences [1..n]) == 2^n

-- 40 minutes including discussing with Bert
-- 10 minutes for the initial test
-- + 5 minutes for running and limiting the upper limit
-- Finding this test was not hard. The test itself runs however very long.
-- This is (probably) caused by the fact that QuickCheck generated a wide range of numbers and since the number of subsequences
-- grows exponentially determining the left hand side of the test can take an infinite amount of time.
-- Since the test only tests a very limited number of values it only checks if 'subsequences' satifies the specification.


-- ASSIGNMENT 1.3 --
-- Permutations

fact :: Integral i => i -> i
fact 0 = 1
fact n = n * fact (n - 1)

permutationsSizeTest :: (Positive Int) -> Bool
permutationsSizeTest (Positive n) = n <= 10 --> length (permutations [1..n]) == fact n

-- Once again this test is way to slow to be practical. So in the end we test only if the specification is partially satiafied.

-- 20 minutes


-- ASSIGNMENT 1.4 --

isReversalPrime :: Integer -> Bool
isReversalPrime n = prime (reversal n)

reversalPrimes :: [Integer]
reversalPrimes = filter isReversalPrime (takeWhile (< 10000) primes)

-- 15 minutes writing the reversalPrimes function
-- 

-- ASSIGNMENT 1.5 --

sumsOfNElements :: Int -> [Integer] -> [Integer]
sumsOfNElements n xs = [sum(take n xs)] ++ sumsOfNElements n (tail xs)

firstPrimeOfSumOf101Primes :: Integer
firstPrimeOfSumOf101Primes = head (filter prime (sumsOfNElements 101 primes))

-- 1 hour including discussing with teammates
-- The function firstPrimeOfSumOf101Primes uses standard Haskell constructs and is straight forward.
-- So the only part that should be checked is the summation of n consequtive numers, aka the sumsOfNElements function.
-- Another way is checking that the example provided in the assignment if present.

firstPrimeOfSumOf5PrimesTest :: Bool
firstPrimeOfSumOf5PrimesTest = any (==101) (filter prime (sumsOfNElements 5 primes))

-- ASSIGNMENT 1.6 --

productOfNElements :: Int -> [Integer] -> Integer
productOfNElements n xs = product(take n xs) + 1

counterExamplesPrimesProductIsPrime :: [Int]
counterExamplesPrimesProductIsPrime = [n | n <- [1..], not (prime (productOfNElements n primes))]

smallesCounterExample :: Int
smallesCounterExample = head counterExamplesPrimesProductIsPrime

-- ASSIGNMENT 1.7 --

luhnDouble :: Integer -> Integer
luhnDouble n | x < 10    = x
             | otherwise = x - 9
           where x = 2 * n

luhnify :: Integer -> Integer
luhnify x | x < 10    = x
          | x < 100   = mod x 10 + luhnDouble (x `div` 10)
          | otherwise = luhnify (mod x 100) + luhnify (x `div` 100)

isValidLuhn :: Integer -> Bool
isValidLuhn n = mod (luhnify n) 10 == 0

isValidLuhnTest :: Bool
isValidLuhnTest = isValidLuhn 79927398713

isValidLength :: Int -> Integer -> Bool
isValidLength n x = x >= 10^(n-1) && x < 10^n

-- Using show is more accurate then logBase 10 since that returns a number and I have seen cases
-- where it was rounded up while it should not have been rounded up!
fitToLengthOfMask :: Integer -> Integer -> Integer
fitToLengthOfMask n m = n `div` (10 ^ (length (show n) - length (show m)))

startsWithAny :: Integer -> [Integer] -> Bool
startsWithAny n ms = or [ fitToLengthOfMask n m == m | m <- ms]

americanExpresIINs = [34, 36]
isAmericanExpress :: Integer -> Bool
isAmericanExpress x = isValidLuhn x && isValidLength 15 x && startsWithAny x americanExpresIINs

masterCardIINs = [51..55] ++ [2221..2720]
isMastercard :: Integer -> Bool
isMastercard x = isValidLuhn x && isValidLength 16 x && startsWithAny x masterCardIINs

visaIINs = [4]
isVisa :: Integer -> Bool
isVisa x = isValidLuhn x && isValidLength 16 x && startsWithAny x visaIINs

-- Test

-- Check that a creditcard number is valid for a single company
validate :: Integer -> (Integer -> Bool) -> [(Integer -> Bool)] -> Bool
validate x v fs = v x && not (or [ f x | f <- fs ])

isValidAmericanExpress :: Integer -> Bool
isValidAmericanExpress x = validate x isAmericanExpress [isMastercard, isVisa]

isValidMastercard :: Integer -> Bool
isValidMastercard x = validate x isMastercard [isAmericanExpress, isVisa]

isValidVisa :: Integer -> Bool
isValidVisa x = validate x isVisa [isAmericanExpress, isMastercard]

-- 1 hour, rough version
-- 30 minutes refactoring IIN identification
-- 20 minutes adding validation per company

-- ASSIGNMENT 1.8 --

xor :: Bool -> Bool -> Bool
xor p q = (p || q) && not (p && q)

-- Set like equals operators that are not sensitive for the order of the elements in the list
equals :: (Eq a) => [a] -> [a] -> Bool
equals xs ys = length xs == length ys && and [ elem x ys | x <- xs]

notEquals :: [Boy] -> [Boy] -> Bool
notEquals xs ys = not (equals xs ys)


accuses :: Boy -> Boy -> Bool
accuses Matthew accused = not (elem accused [Carl, Matthew])
accuses Peter accused   = elem accused [Matthew, Jack]
accuses Jack accused    = not (accuses Matthew accused) && not (accuses Peter accused)
accuses Arnold accused  = xor (accuses Matthew accused) (accuses Peter accused)
accuses Carl accused    = not (accuses Arnold accused)

accusers :: Boy -> [Boy]
accusers accusee = [b | b <- boys, accuses b accusee]

-- The following two function capture the knowledge of the teacher
-- Three boys are telling the truth.
potentialAngels :: [[Boy]]
potentialAngels = filter (\ bs -> length bs == 3) (subsequences boys)

-- Two boys are lying given the possible angels
potentialLiers :: [Boy] -> [Boy]
potentialLiers ys = boys \\ ys

truthfullyAccusedBy :: Boy -> [Boy] -> Bool
truthfullyAccusedBy c ys = accusers c `equals` ys

falselyAccusedBy :: Boy -> [Boy] -> Bool
falselyAccusedBy c xs = accusers c `notEquals` xs

judge :: [(Boy, [Boy])]
judge = [ ([c], ys) | c <- boys, ys <- potentialAngels, truthfullyAccusedBy c ys && falselyAccuses c (potentialLiers ys)]

guilty :: [Boy]
guilty = [fst (head judge)]

honest :: [Boy]
honest = snd (head judge)

-- 3 hours. 

