
module Lab2 where

import Data.List
import Data.Char
import System.Random
import Test.QuickCheck

infix 1 --> 

(-->) :: Bool -> Bool -> Bool
p --> q = (not p) || q

probs :: Int -> IO [Float]
probs 0 = return []
probs n = do
             p <- getStdRandom random
             ps <- probs (n-1) 
             return (p:ps)

data Shape = NoTriangle | Equilateral 
           | Isosceles  | Rectangular | Other deriving (Eq,Show)


-- ASSIGNMENT 1 --

-- Map every quartile to a integer number starting from 0
-- (0..0.25)   -> 0
-- [0.25..0.5) -> 1
-- [0.5..0.75) -> 2
-- [0.75..1)   -> 3
floatToClass :: Float -> Integer
floatToClass x = toInteger (floor (4.0 * x))

-- Check if two values belong to the same 
isSameClass :: Float -> Float -> Bool
isSameClass x y = floatToClass x == floatToClass y

-- Group the sorted values according to their class
groupValues :: [Float] -> [[Float]]
groupValues xs = groupBy isSameClass (sort xs)

-- Generates a number of random values, divides them into quartiles, determines
-- the distribution and print the results, including the maximum deviation from
-- the mean. The mean is defined as the number of generated numbers over 4.
-- The number of random numbers that needs to be generated is the input parameter
-- of this function.
checkRandomness :: Int -> IO ()
checkRandomness n = do
                      values <- probs n
                      let quartiles = groupValues values
                      let distribution = map length quartiles
                      putStrLn "Number of values in each quartile."
                      print distribution
                      let mean = n `div` 4
                      let maxDeviation = maximum (map (\x -> abs(x - mean)) distribution)
                      putStrLn "The maximum deviation from the mean "
                      print maxDeviation
                      putStrLn "That is as percentage"
                      print ((100 * maxDeviation) `div` mean)

-- Time spend: 1 hour


-- ASSIGNMENT 2 --

-- The input is illegal if there are any values less then or equal to zero
isIllegal :: Int -> Int -> Int -> Bool
isIllegal a b c = a <= 0

isEquilateral :: Int -> Int -> Int -> Bool
isEquilateral a b c = a == b && b == c

-- Using the fact that the lengths are ordered the two longest need to be equal
-- to make it a isosceles triangle
isIsosceles :: Int -> Int -> Int -> Bool
isIsosceles a b c = b == c

isRectangular :: Int -> Int -> Int -> Bool
isRectangular a b c = a^2 + b^2 == c^2

isTriangle :: Int -> Int -> Int -> Bool
isTriangle a b c = a + b > c

-- The properties are placed in descending strength from top to bottom.
-- If a property does not hold a weaker property is tested.
-- All property check expect the parameters are sorted in ascending order.
triangle :: Int -> Int -> Int -> Shape
triangle x y z | isIllegal a b c     = NoTriangle
               | isEquilateral a b c = Equilateral
               | isIsosceles a b c   = Isosceles
               | isRectangular a b c = Rectangular
               | isTriangle a b c    = Other
               | otherwise           = NoTriangle
               where
                  abc = sort [x, y, z]
                  a = abc !! 0
                  b = abc !! 1
                  c = abc !! 2
-- Time spend: 1:45

-- Any number less zero can't result in a triangle.
-- By making one positive number negative this condition is assured.
-- By shuffeling the order of the values we make sure that the negative number
-- is randomy distributed over the sides.
negativeLengthTest :: (Positive Int) -> (Positive Int) -> (Positive Int) -> Bool
negativeLengthTest (Positive x) (Positive y) (Positive z) = triangle a b c == NoTriangle
                          where
                            abc = head (permutations [-x, y, z])
                            a = abc !! 0
                            b = abc !! 1
                            c = abc !! 2

-- By shuffeling the order of the values (with a single zero) we make sure that the zero
-- is randomy distributed over the sides.
zeroLengthTest :: (Positive Int) -> (Positive Int) -> Bool
zeroLengthTest (Positive x) (Positive y) = triangle a b c == NoTriangle
                          where
                            abc = head (permutations [x, y, 0])
                            a = abc !! 0
                            b = abc !! 1
                            c = abc !! 2

-- The sides of a equilateral triangles are all the same, so we make one by using a single
-- random number generated by QuickCheck
equilateralTest :: (Positive Int) -> Bool
equilateralTest (Positive x) = triangle x x x == Equilateral

-- When QuickCheck generates a number greater or equal to 2 we can subtract 1 from it
-- for once side to make a isosceles triangle.
isoscelelTest :: (Positive Int) -> Bool
isoscelelTest (Positive x) = (x >= 2) --> triangle a b c == Isosceles
                          where
                            abc = head (permutations [x, x, x-1])
                            a = abc !! 0
                            b = abc !! 1
                            c = abc !! 2
